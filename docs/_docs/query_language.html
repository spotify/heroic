---
title: Heroic Query Language
---
<h2>{{ page.title }}</h2>

<p>
  Heroic uses a JSON-based language to define queries.
  This can also be expressed using an experimental DSL called HQL
  (Heroic Query Language).
</p>

<div class="callout callout-danger">
  <h4>Experimental</h4>
  <p>
    The HQL should currently be considered experimental and might be subject to future changes.
  </p>
</div>

<p>
  Queries have the following structure.
</p>

<codeblock language="hql">
&lt;aggregation&gt;
  [from &lt;source&gt;]
  [where &lt;filter&gt;]
  [as &lt;key&gt;=&lt;value&gt;[,&lt;key&gt;=&lt;value&gt;]]
  [with &lt;key&gt;=&lt;value&gt;[,&lt;key&gt;=&lt;value&gt;]];
</codeblock>

<p>
  References have the following structures.
</p>

<codeblock language="hql">
let $&lt;name&gt; = &lt;query&gt;;
</codeblock>

<p>
  <em>Complex Queries</em> are queries referencing other queries through a
  reference.
  The following is an example of this
</p>

<codeblock language="hql">
let $a = average by host | sum by site;

$a / shift($a, -7d) - 1.0
  where what = cpu-usage and role = heroic;
</codeblock>

<p>
  The following is a complete example of a HQL-based query:
</p>

<codeblock language="hql">
average by host | sum by site
  from points(1d)
  where role=heroic and what=cpu-idle
  with size=5m
</codeblock>

<h3 id="json-dsl">JSON vs HQL</h3>

<p>
  JSON is typically used when a query is built programatically because the structure is unambigious in terms of precedence and escaping.
  There is also a ton of language support for it, and it meshes well with restful APIs.
</p>

<p>
  The HQL was developed to make it easier for humans to express queries or filters in a manner which is more convenient.
  The language is infix, and simple strings do not have to be escaped (e.g. <code language="hql">host</code> vs. <code language="hql">&quot;host&quot;</code>)
</p>

<p>
  A primary Goal of the HQL is that it should act as a complement to the JSON queries.
  Any query can be expressed either in JSON or HQL.
</p>

<p>
  The following is an example filter expressed both in a JSON, and in the HQL.
</p>

<pre><code language="hql">
$key = "hello kitty" and host = foo.example.com
</code><code language="json">
["and", ["$key", "hello kitty"], ["=", "host", "foo.example.com"]]
</code></pre>

<p>
  To test this principle you can fire up the <a ui-sref="^.shell">Heroic Shell</a> and run the following commands:
</p>

<codeblock language="bash">
$ tools/heroic-shell

heroic> parse-query --no-indent "average by host | sum by site"
{"aggregation":{"type":"chain","chain":[{"type":"group","of":["host"],"each":{"type":"sum"}},{"type":"average"}]}}
</codeblock>

<h3>Aggregations</h3>

<p>
  Main Article: <a ui-sref="^.aggregations">Aggregations</a>
</p>

<p>
  Aggregations are expressed as function calls, or typed documents.
  See the following example using the <a ui-sref="^.aggregations({'#': 'sum'})">sum</a> aggregation.
</p>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <td>
      <codeblock language="hql">
      sum(3m)
      </codeblock>
    </td>
    <td>
      <codeblock language="json">
      {"type": "sum", "size": "3m"}
      </codeblock>
    </td>
  </tr>
</table>
</div>

<p>
  There is also syntactic sugar for the special
  <a ui-sref="^.aggregations({'#': 'group'})">group</a> and
  <a ui-sref="^.aggregations({'#': 'chain'})">chain</a>
  aggregations.
</p>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <td>
      <codeblock language="hql">
      empty by host
      </codeblock>
    </td>
    <td>
      <codeblock language="json">
      {"type": "group", "of": ["host"], "each": {"type": "empty"}}
      </codeblock>
    </td>
  </tr>
  <tr>
    <td>
      <codeblock language="hql">
      average(size=5m) | sum(size=10m)
      </codeblock>
    </td>
    <td>
      <codeblock language="json">
      {
        "type": "chain",
        "chain": [
          {"type": "average", "size": "5m"},
          {"type": "sum", "size": "10m"}
        ]
      }
      </codeblock>
    </td>
  </tr>
</table>
</div>

<h3>Filters</h3>

<p>
  A filter reduces the number of selected time series, if no filter (or the <a ui-sref="{'#':'filter-true'}">true filter</a>) is used, then it is implied that <em>all</em> time series in the database is selected.
</p>

<img style="width: 100%;" src="images/filter-dsl.svg"></img>

<h3>Available Filters</h3>

<h4>Boolean Operators</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th></th>
    <th>Description</th>
    <th>Parsed</th>
    <th>JSON</th>
  </tr>

  <tr>
    <th scope="row">And</th>
    <td>Matches if all child statements match. <code language="hql">true</code> if empty.</td>
    <td><pre><code language="hql">&lt;a&gt; and &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["and", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Or</th>
    <td>Matches if any child statements match. <code language="hql">false</code> if empty.</td>
    <td><pre><code language="hql">&lt;a&gt; or &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["or", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Not</th>
    <td>Matches if child statement does not match.</td>
    <td><pre><code language="hql">!&lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["not", &lt;a&gt;]</code></pre></td>
  </tr>
</table>
</div>

<h4>Operators</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th></th>
    <th>Parsed</th>
    <th>JSON</th>
  </tr>

  <tr>
    <th scope="row">Tag Matches</th>
    <td><pre><code language="hql">&lt;a&gt; = &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["=", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Does Not Match</th>
    <td><pre><code language="hql">&lt;a&gt; != &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["not", ["=", &lt;a&gt;, &lt;b&gt;]]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Starts With</th>
    <td><pre><code language="hql">&lt;a&gt; ^ &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["^", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Does Not Start With</th>
    <td><pre><code language="hql">&lt;a&gt; !^ &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["not", ["^", &lt;a&gt;, &lt;b&gt;]]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Key Matches</th>
    <td><pre><code language="hql">$key = &lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["key", &lt;a&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Key Does Not Match</th>
    <td><pre><code language="hql">$key != &lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["not", ["key", &lt;a&gt;]]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Exists</th>
    <td><pre><code language="hql">+&lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["+", &lt;a&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag In</th>
    <td><pre><code language="hql">&lt;a&gt; in [&lt;b&gt;, ..]</code></pre></td>
    <td><pre><code language="json">["or", ["=", &lt;a&gt;, &lt;b&gt;], ..]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Not In</th>
    <td><pre><code language="hql">&lt;a&gt; not in [&lt;b&gt;, ..]</code></pre></td>
    <td><pre><code language="json">["not", ["or", ["=", &lt;a&gt;, &lt;b&gt;], ..]]</code></pre></td>
  </tr>
</table>
</div>

<h3>The HQL Language</h3>

<h4>Primitives</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th scope="row">Simple String</th>
    <td>
      String made up of a limited set of characters for convenience.
      It must not match a <a href="#parsed-keyword">parsed keyword</a>.
    </td>
    <td>
      <pre><code language="hql">hello.world</code></pre>
    </td>
  </tr>

  <tr>
    <th scope="row">Quoted String</th>
    <td>String which is quoted to support <em>any</em> set of characters. Supports the same <a href="https://docs.oracle.com/javase/tutorial/java/data/characters.html">escape sequences as Java</a>.</td>
    <td>
      <pre><code language="hql">"hello world"</code></pre>
    </td>
  </tr>
</table>
</div>

<h4>Arithmetic Expressions</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th scope="row">Addition</th>
    <td><pre><code language="hql">&lt;a&gt; + &lt;b&gt;</code></pre></td>
    <td>
      Valid operands are:
      <code language="hql">&lt;string&gt; + &lt;string&gt;</code>,
      and <code language="hql">&lt;number&gt; + &lt;number&gt;</code>.
    </td>
  </tr>

  <tr>
    <th scope="row">Subtraction</th>
    <td><pre><code language="hql">&lt;a&gt; - &lt;b&gt;</code></pre></td>
    <td>
      Valid operands are:
      <code language="hql">&lt;number&gt; - &lt;number&gt;</code>.
    </td>
  </tr>
</table>
</div>

<h4 id="special-variables">Special Variables</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <td><code language="hql">$key</code></td>
    <td>Can be used in most places a tag is expected. It indicates that the given expression should match the special field <em>key</em> instead of a tag.</td>
  </tr>

  <tr>
    <td><code language="hql">$now</code></td>
    <td>Expands to the current (server-side) timestamp in milliseconds.</td>
  </tr>
</table>
</div>

<h4 id="duration">Durations</h4>

<p>
  Durations are represented as a numeric component with a suffix, like <code language="hql">3H</code>
</p>

<p>
  Valid suffixes are:
</p>

<ul>
  <li><b>ms</b> - for milliseconds</li>
  <li><b>s</b> - for seconds</li>
  <li><b>m</b> - for minutes</li>
  <li><b>H</b> - for hours</li>
  <li><b>d</b> - for days</li>
  <li><b>w</b> - for weeks</li>
</ul>

<p>
  Durations support arithmetic expressions with each other and numbers.
</p>

<p>
  The following is a valid expression:
</p>

<codeblock language="hql">
$now - (1d + 1H)
</codeblock>
